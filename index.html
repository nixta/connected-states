<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Connected States</title>

  <link rel="stylesheet" href="https://js.arcgis.com/4.0/esri/css/main.css">
  
  <style>
    html, body, #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
    }

    #instructions {
      padding: 0.9em;
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #DDD;
      text-align: center;
      border-radius: 5px;
      z-index: 1000;
      font-family: Sans-Serif;
      pointer-events: none;
      opacity: 0.6;
    }
  </style>

  <script src="https://js.arcgis.com/4.0/"></script>

  <script>
    require([
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/layers/TileLayer",
      "esri/layers/GraphicsLayer",
      "esri/renderers/SimpleRenderer",
      "esri/symbols/SimpleMarkerSymbol",
      "esri/symbols/SimpleLineSymbol",
      "esri/symbols/TextSymbol",
      "esri/Graphic",
      "esri/geometry/Polyline",
      "esri/geometry/geometryEngine",
      "esri/tasks/QueryTask",
      "esri/tasks/support/Query",
      "esri/widgets/Zoom",
      "esri/core/watchUtils",
      "dojo/Deferred",
      "dojo/domReady!"
    ], function(Map, MapView, 
      FeatureLayer, TileLayer, GraphicsLayer, 
      SimpleRenderer, SimpleMarkerSymbol, SimpleLineSymbol, TextSymbol, 
      Graphic, Polyline, geometryEngine,
      QueryTask, Query,
      Zoom, watchUtils, Deferred) {



      // Config variables
      var totalAnimationDuration = 30.0;
      var maxFramesPerSecond = 30;
      var stopsServiceURL = "https://services.arcgis.com/OfH668nDRN7tbJh0/arcgis/rest/services/ConnectedStates/FeatureServer/0";



      // Set up some layers to show the animation
      var hopsGraphicsLayer = new GraphicsLayer({
            renderer: new SimpleRenderer({
              symbol: new SimpleLineSymbol({
                color: [255,0,0, 1],
                width: 3
              })
            })
          }),
          citiesGraphicsLayer = new GraphicsLayer({
            renderer: new SimpleRenderer({
              symbol: new SimpleMarkerSymbol({
                style: "circle",
                color: [194,194,194,0.5],
                size: "10px",  // pixels
                outline: {  // autocasts as esri/symbols/SimpleLineSymbol
                  color: [153,153,153],
                  width: 1.125  // points
                }
              })
            })
          });



      // Create the map.
      var map = new Map({
        basemap: {
          baseLayers: [new TileLayer({
            url: "https://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Dark_Gray_Base/MapServer"
          })]
        },
        layers: [
          hopsGraphicsLayer,
          citiesGraphicsLayer
        ]
      });

      var view = new MapView({
        container: "viewDiv",
        map: map,
        center: [-100.68, 45.52], // lon, lat
        zoom: 10
      });



      // Create query task to load the cities
      var queryTask = new QueryTask({
        url: stopsServiceURL
      });

      // Make sure we get back the attributes we need, and order appropriately
      var query = new Query({
        returnGeometry: true,
        outFields: ["City", "State", "Sequence"],
        where: "1=1",
        orderByFields: ["Sequence"]
      });

      // Perform query when page loads
      queryTask.execute(query).then(function(results) {
        watchUtils.whenTrueOnce(view, "ready", function() {
          // Parse the data, and prepare the data for animation
          var cityHops = parseCityHops(results.features);

          // Zoom Map
          view.goTo(cityHops.map(function(hop) {
            return hop.line;
          }));

          cueCityHopsAnimation(cityHops);
        });
      });



      function cueCityHopsAnimation(cityHops) {
        var hopAnimationDuration = totalAnimationDuration / cityHops.length,
            framesPerHop = hopAnimationDuration * maxFramesPerSecond;

        var clickEvent = view.on("click", startAnimation);

        function startAnimation() {
          view.ui.empty("top-left");
          document.body.style.cursor = "none";
          document.getElementById("instructions").style.display = "none";
          clickEvent.remove();

          hopsGraphicsLayer.removeAll();
          citiesGraphicsLayer.removeAll();

          // Delay the animation very slightly after clearing the UI
          // This allows us to cut appropriately in Video Editing software if recording
          // the animation...
          window.setTimeout(function (){ 

            var tripAnimation = doAnimation(cityHops, hopsGraphicsLayer, citiesGraphicsLayer);

            tripAnimation.then(function () {

              window.setTimeout(function restoreUI() {
                
                view.ui.add(new Zoom({
                  view: view
                }), "top-left");                
                document.body.style.cursor = "default";
                document.getElementById("instructions").style.display = "";

                clickEvent = view.on("click", startAnimation);

              }, 750);

            }); 

          }, 750);
        }

        function doAnimation(cityHops, hopsGraphicsLayer, citiesGraphicsLayer) {
          var deferred = new Deferred();

          hopsGraphicsLayer.removeAll();
          citiesGraphicsLayer.removeAll();

          startHopAnimation();
            
          return deferred;

          function startHopAnimation() {
            var start;
            var currentIndex = 0;
            var lastPointCount = 0;

            var completedHopsLine = new Polyline({
              spatialReference: view.spatialReference
            });

            window.requestAnimationFrame(updateAnimation); 

            function updateAnimation(timeStamp) { 
              // Let's figure out where we should be in the animation for this timestamp.
              var currentHopInfo = cityHops[currentIndex];

              if (!start) {
                // If we just started a hop, we remember this timestamp.
                start = timeStamp;
                if (currentIndex == 0) {
                  showCity(currentHopInfo.startCity, citiesGraphicsLayer);
                }
              }

              // Get as much line as we need for as far through this hop's animation as we are
              var subLine = getSubline(currentHopInfo.geodesicLine, timeStamp, start, hopAnimationDuration * 1000);

              var subLineCount = pointsInLine(subLine);

              if (subLineCount == lastPointCount) {
                // Nothing to update since last animation call - jump on out
                window.requestAnimationFrame(updateAnimation);
                return
              }

              // We need to update the polyline graphic as part of the animation.
              lastPointCount = subLineCount;

              var hopProgress = subLineCount / pointsInLine(currentHopInfo.geodesicLine);

              var totalTravelLine = completedHopsLine.paths.length == 0 ? subLine : geometryEngine.union([completedHopsLine, subLine]);

              var totalGraphic = new Graphic({
                geometry: totalTravelLine
              });

              hopsGraphicsLayer.removeAll();
              hopsGraphicsLayer.add(totalGraphic);

              // var segLen = geometryEngine.geodesicLength(subLine, "miles");
              // var totLen = geometryEngine.geodesicLength(totalTravelLine, "miles");
              // console.log(Math.round(hopProgress*100) + "% done with segment " + (currentIndex+1) + " of " + cityHops.length + " [" + segLen + " miles, total " + totLen + " miles]");

              // If we reached the end of a hop, display the city that's at the end of it and move on to the next hop.
              if (hopProgress == 1) {
                // First update the overall "completed hops" polyline.
                for (var p=0; p < subLine.paths.length; p++) {
                  completedHopsLine.addPath(subLine.paths[p]);
                }

                // Move on to the next hop and reset the timing info
                currentIndex += 1;
                start = undefined;
                lastPointCount = 0;

                showCity(currentHopInfo.endCity, citiesGraphicsLayer);
              }

              // Check if we're done. If we are, good, resolve the deferred and get outta here. Otherwise, repeat when the next animation opportunity comes up.
              if (currentIndex < cityHops.length) {
                window.requestAnimationFrame(updateAnimation); 
              } else {
                deferred.resolve();
              }
            }
          }
        }
      }



      /// Data Visualization
      function showCity(city, citiesGraphicsLayer) {
        citiesGraphicsLayer.add(city);
        citiesGraphicsLayer.add(labelForCity(city));
      }

      function labelForCity(city) {
        var yOffset = city.attributes.__label_yOffset || 0;
        var alignment = city.attributes.__label_alignment || "center";

        var labelGraphic = new Graphic({
          geometry: city.geometry,
          symbol: new TextSymbol({
            color: "white",
            haloColor: "black",
            haloSize: "3px",
            text: city.attributes.City, // city.attributes.Sequence + ": " + city.attributes.City
            xoffset: 0,
            yoffset: yOffset,
            horizontalAlignment: alignment,
            font: {  // autocast as esri/symbols/Font
              size: 12,
              family: "sans-serif",
              weight: "light"
            }
          })
        });

        return labelGraphic;
      }


      /// City Data Parsing
      function parseCityHops(cityFeatures) {
        var hops = [];
        var hopCount = Math.max(cityFeatures.length, 0);
        var hopAnimationDuration = totalAnimationDuration / hopCount,
            framesPerHop = hopAnimationDuration * maxFramesPerSecond;

        var labelConfig = {
          offsetBelow: [3,4,9,13,17,19,20,23,25,30,42],
          leftAlign: [1,5,6,11,15,22,23,24,27,33,38,42,44],
          rightAlign: [8,16,17,18,19,21,28,30,34,35,36,37,39,40,43]
        }

        var previousCity = undefined;
        for (var i=0; i < cityFeatures.length; i++) {
          var city = cityFeatures[i];

          var citySequence = city.attributes.Sequence,
              yOffset = (labelConfig.offsetBelow.indexOf(citySequence) > -1) ? -14 : 7,
              alignment = (labelConfig.leftAlign.indexOf(citySequence) > -1) ? "left" : 
                            ((labelConfig.rightAlign.indexOf(citySequence) > -1) ? "right" : "center");

          city.attributes["__label_yOffset"] = yOffset;
          city.attributes["__label_alignment"] = alignment;

          if (previousCity !== undefined) {
            var prevPoint = previousCity.geometry,
                currPoint = city.geometry,
                hopLine = new Polyline({
                  paths: [[prevPoint.x, prevPoint.y], [currPoint.x, currPoint.y]],
                  spatialReference: view.spatialReference
                }),
                hopLength = geometryEngine.geodesicLength(hopLine, "miles"),
                densifyLength = hopLength / framesPerHop,
                geodesicHopLine = geometryEngine.geodesicDensify(hopLine, densifyLength, "miles");


            hops.push({
              startCity: previousCity,
              endCity: city,
              line: hopLine,
              geodesicLine: geodesicHopLine
            });
          }

          previousCity = city;
        }

        return hops;
      }


      /// Polyline Utility Functions
      function pointsInLine(polyline) {
        var pointCount = 0;
        for (var p=0; p < polyline.paths.length; p++) {
          pointCount += polyline.paths[p].length;
        }
        return pointCount;
      }

      function getSubline(totalLine, timeStamp, startTime, duration) {
        var progress = (timeStamp - startTime) / duration,
            lastPointIndex = Math.round(totalLine.paths[0].length * progress);
            // ^^^ Assumes we have just one path with all the points in it.

        // Assuming a single path with multiple points
        var subLine = new Polyline({
          paths: [totalLine.paths[0].slice(0,Math.max(0,lastPointIndex))],
          spatialReference: totalLine.spatialReference
        })
        
        return subLine;
      }
    });
  </script>
</head>

<body>
  <div id="instructions">Click the map to animate</div>
  <div id="viewDiv"></div>
</body>
</html>